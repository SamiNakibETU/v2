"""
Ultra-Precise Link Resolver
Ensures all URLs come from real OLJ articles, never generated by LLM
"""

import logging
from typing import Literal

from app.models.schemas import (
    QueryPlan,
    LinkResolutionResult,
    RetrievalCandidate,
    RecipeArticle,
)
from app.data.link_index import LinkIndex
from app.models.config import settings

logger = logging.getLogger(__name__)


class LinkResolver:
    """
    Ultra-precise link resolver that ONLY uses real OLJ article URLs

    Key guarantees:
    - All URLs come from LinkIndex (loaded from actual JSON data)
    - No URL generation or hallucination by LLM
    - Only https://www.lorientlejour.com domain
    - Deterministic fallback strategy when no match found
    """

    def __init__(self, link_index: LinkIndex):
        self.link_index = link_index

    def resolve(
        self,
        query_plan: QueryPlan,
        retrieval_candidates: list[RetrievalCandidate] | None = None,
    ) -> LinkResolutionResult:
        """
        Resolve the best OLJ article link for a query

        Args:
            query_plan: The query plan with link_query
            retrieval_candidates: Optional retrieval results for context

        Returns:
            LinkResolutionResult with primary_article and suggested_articles
        """
        # No link needed for non-food intents
        if query_plan.need_type in ["greeting", "about_bot", "off_topic"]:
            return LinkResolutionResult(
                primary_article=None,
                suggested_articles=[],
                strategy="no_link_needed",
                confidence=1.0,
            )

        # Try to find exact or best match
        if query_plan.link_query:
            result = self._resolve_with_query(query_plan.link_query, query_plan.need_type)
            if result.primary_article:
                return result

        # Try to extract article from retrieval candidates
        if retrieval_candidates:
            result = self._resolve_from_candidates(retrieval_candidates)
            if result.primary_article:
                return result

        # Fallback: use recent/popular articles
        return self._resolve_fallback(query_plan.need_type)

    def _resolve_with_query(
        self,
        link_query: str,
        need_type: str,
    ) -> LinkResolutionResult:
        """Resolve using link query"""

        # Try exact match first
        exact_match = self.link_index.find_exact_match(link_query)
        if exact_match:
            logger.info(f"Found exact match for '{link_query}': {exact_match.url}")
            return LinkResolutionResult(
                primary_article=exact_match,
                suggested_articles=self._get_related_articles(exact_match, count=2),
                strategy="exact_match",
                confidence=1.0,
            )

        # Try similarity search
        matches = self.link_index.find_best_match(
            link_query,
            top_k=3,
            min_score=settings.min_similarity_threshold,
        )

        if matches:
            best_article, best_score, best_strategy = matches[0]

            # Build suggested articles from other matches
            suggested = [article for article, _, _ in matches[1:]]

            logger.info(
                f"Found {best_strategy} match for '{link_query}': {best_article.url} (score: {best_score:.2f})"
            )

            return LinkResolutionResult(
                primary_article=best_article,
                suggested_articles=suggested,
                strategy=best_strategy,
                confidence=best_score,
            )

        # No match found
        return LinkResolutionResult(
            primary_article=None,
            suggested_articles=[],
            strategy="no_match",
            confidence=0.0,
        )

    def _resolve_from_candidates(
        self,
        candidates: list[RetrievalCandidate],
    ) -> LinkResolutionResult:
        """Extract article from retrieval candidates"""

        # Find first OLJ candidate with an article_id
        for candidate in candidates:
            if candidate.source == "olj" and candidate.article_id:
                article = self.link_index.get_article_by_id(candidate.article_id)
                if article:
                    logger.info(f"Resolved article from retrieval: {article.url}")
                    return LinkResolutionResult(
                        primary_article=article,
                        suggested_articles=self._get_related_articles(article, count=2),
                        strategy="from_retrieval",
                        confidence=candidate.score,
                    )

        # No OLJ candidate found
        return LinkResolutionResult(
            primary_article=None,
            suggested_articles=[],
            strategy="no_olj_candidate",
            confidence=0.0,
        )

    def _resolve_fallback(self, need_type: str) -> LinkResolutionResult:
        """
        Fallback strategy when no match is found

        Uses recent/popular articles as safe defaults
        """
        # Determine fallback strategy based on need type
        if need_type == "recipe_by_ingredients":
            # For ingredient queries, show recent recipes
            strategy = "recent"
        elif need_type == "suggestions":
            # For suggestions, show popular recipes
            strategy = "popular"
        else:
            # Default: recent
            strategy = "recent"

        fallback_articles = self.link_index.get_fallback_articles(
            strategy=strategy,
            count=3,
        )

        if fallback_articles:
            primary = fallback_articles[0]
            suggested = fallback_articles[1:]

            logger.info(f"Using fallback ({strategy}): {primary.url}")

            return LinkResolutionResult(
                primary_article=primary,
                suggested_articles=suggested,
                strategy=f"fallback_{strategy}",
                confidence=0.3,  # Low confidence for fallback
            )

        # No fallback articles available (shouldn't happen)
        logger.error("No fallback articles available!")
        return LinkResolutionResult(
            primary_article=None,
            suggested_articles=[],
            strategy="no_fallback",
            confidence=0.0,
        )

    def _get_related_articles(
        self,
        article: RecipeArticle,
        count: int = 2,
    ) -> list[RecipeArticle]:
        """Get related articles based on tags or chef"""
        related = []

        # Try to find articles with same tags
        if article.tags:
            for tag in article.tags[:2]:  # Try first 2 tags
                tag_articles = self.link_index.get_articles_by_tag(tag, limit=3)
                for art in tag_articles:
                    if art.article_id != article.article_id and art not in related:
                        related.append(art)
                        if len(related) >= count:
                            return related

        # Try articles by same chef
        if article.chef:
            chef_articles = self.link_index.get_articles_by_chef(article.chef, limit=3)
            for art in chef_articles:
                if art.article_id != article.article_id and art not in related:
                    related.append(art)
                    if len(related) >= count:
                        return related

        # Fill with recent articles if needed
        if len(related) < count:
            recent = self.link_index.get_fallback_articles("recent", count=count)
            for art in recent:
                if art.article_id != article.article_id and art not in related:
                    related.append(art)
                    if len(related) >= count:
                        return related

        return related[:count]

    def validate_url(self, url: str) -> bool:
        """
        Validate that a URL is from the allowed domain

        This is a safety check to ensure no generated URLs leak through
        """
        if not url:
            return False

        return url.startswith(settings.allowed_url_domain)

    def get_article_by_url(self, url: str) -> RecipeArticle | None:
        """Get an article by its URL (exact match)"""
        if not self.validate_url(url):
            logger.warning(f"Invalid URL domain: {url}")
            return None

        # Linear search through link index
        for doc in self.link_index.documents:
            if doc.article.url == url:
                return doc.article

        return None
